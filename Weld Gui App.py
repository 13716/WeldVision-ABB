import sys
import threading
import socket
import json
from PyQt5.QtWidgets import (
    QApplication, QWidget, QPushButton, QLabel, QTextEdit, QLineEdit,
    QFileDialog, QVBoxLayout, QHBoxLayout, QGroupBox, QGridLayout
)
from PyQt5.QtGui import QPixmap, QImage
from PyQt5.QtCore import Qt, pyqtSignal, QObject
import cv2
import numpy as np
import matplotlib.pyplot as plt
from weld_library import WeldDetectorPro

class ServerSignals(QObject):
    new_log = pyqtSignal(str)
    connection_status = pyqtSignal(bool)
    path_requested = pyqtSignal()

class WeldGUI(QWidget):
    def __init__(self):
        super().__init__()
        self.detector = None
        self.config_path = None
        self.path = []
        self.server_socket = None
        self.client_socket = None
        self.server_running = False
        self.server_thread = None
        self.signals = ServerSignals()
        self.initUI()
        self.setup_signal_connections()

    def setup_signal_connections(self):
        self.signals.new_log.connect(self.append_log)
        self.signals.connection_status.connect(self.update_connection_status)
        self.signals.path_requested.connect(self.handle_path_request)

    def initUI(self):
        self.setWindowTitle("Weld Detector Pro - Robot Server")
        self.setGeometry(100, 100, 900, 750)

        main_layout = QVBoxLayout()

        # --- C·∫•u h√¨nh & Server ---
        config_group = QGroupBox("üîß C·∫•u h√¨nh v√† K·∫øt n·ªëi Server")
        config_layout = QGridLayout()

        self.config_input = QLineEdit()
        browse_btn = QPushButton("Ch·ªçn config.yaml")
        browse_btn.clicked.connect(self.choose_config)

        self.load_btn = QPushButton("T·∫£i c·∫•u h√¨nh")
        self.load_btn.clicked.connect(self.load_detector)

        self.ip_input = QLineEdit("127.0.0.1")
        self.port_input = QLineEdit("5000")
        self.server_btn = QPushButton("M·ªü Server")
        self.server_btn.clicked.connect(self.toggle_server)

        config_layout.addWidget(QLabel("ƒê∆∞·ªùng d·∫´n config:"), 0, 0)
        config_layout.addWidget(self.config_input, 0, 1)
        config_layout.addWidget(browse_btn, 0, 2)

        config_layout.addWidget(QLabel("IP:"), 1, 0)
        config_layout.addWidget(self.ip_input, 1, 1)
        config_layout.addWidget(QLabel("Port:"), 2, 0)
        config_layout.addWidget(self.port_input, 2, 1)
        config_layout.addWidget(self.server_btn, 2, 2)

        config_layout.addWidget(self.load_btn, 3, 1)
        config_group.setLayout(config_layout)
        main_layout.addWidget(config_group)

        # --- Ph√°t hi·ªán ---
        action_group = QGroupBox("ü§ñ Ph√°t hi·ªán v√† Qu·∫£n l√Ω ƒê∆∞·ªùng h√†n")
        action_layout = QHBoxLayout()

        self.detect_btn = QPushButton("Ph√°t hi·ªán m·ªëi h√†n")
        self.detect_btn.clicked.connect(self.detect_weld)
        self.detect_btn.setEnabled(False)

        self.plot_btn = QPushButton("Xem ƒë·ªì th·ªã 3D")
        self.plot_btn.clicked.connect(self.show_plot)
        self.plot_btn.setEnabled(False)
        
        # N√∫t reset ƒë∆∞·ªùng h√†n hi·ªán t·∫°i
        self.reset_path_btn = QPushButton("Reset ƒë∆∞·ªùng h√†n")
        self.reset_path_btn.clicked.connect(self.reset_current_path)
        self.reset_path_btn.setEnabled(False)

        action_layout.addWidget(self.detect_btn)
        action_layout.addWidget(self.plot_btn)
        action_layout.addWidget(self.reset_path_btn)
        action_group.setLayout(action_layout)
        main_layout.addWidget(action_group)

        # --- Hi·ªÉn th·ªã ·∫£nh ROI ---
        self.image_label = QLabel("·∫¢nh camera s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y")
        self.image_label.setAlignment(Qt.AlignCenter)
        self.image_label.setFixedHeight(300)
        main_layout.addWidget(self.image_label)

        # --- Log ---
        self.connection_status_label = QLabel("Tr·∫°ng th√°i k·∫øt n·ªëi: Ch∆∞a k·∫øt n·ªëi")
        self.status_label = QLabel("Tr·∫°ng th√°i: S·∫µn s√†ng")
        self.log_output = QTextEdit()
        self.log_output.setReadOnly(True)

        main_layout.addWidget(self.connection_status_label)
        main_layout.addWidget(self.status_label)
        main_layout.addWidget(self.log_output)

        self.setLayout(main_layout)

    def choose_config(self):
        path, _ = QFileDialog.getOpenFileName(self, 'Ch·ªçn file YAML', '', 'YAML Files (*.yaml)')
        if path:
            self.config_input.setText(path)
            self.config_path = path

    def load_detector(self):
        path = self.config_input.text()
        if not path:
            self.log_output.append("[ERROR] B·∫°n ch∆∞a ch·ªçn file config.")
            return
        try:
            self.detector = WeldDetectorPro(path)
            self.status_label.setText("ƒê√£ t·∫£i c·∫•u h√¨nh th√†nh c√¥ng")
            self.log_output.append("[INFO] C·∫•u h√¨nh ƒë√£ ƒë∆∞·ª£c t·∫£i.")
            self.detect_btn.setEnabled(True)
        except Exception as e:
            self.log_output.append(f"[ERROR] Kh√¥ng th·ªÉ t·∫£i c·∫•u h√¨nh: {e}")

    def toggle_server(self):
        if not self.server_running:
            self.start_server()
            self.server_btn.setText("D·ª´ng Server")
        else:
            self.stop_server()
            self.server_btn.setText("M·ªü Server")

    def start_server(self):
        if self.server_running:
            return

        try:
            host = self.ip_input.text()
            port = int(self.port_input.text())
            
            self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            self.server_socket.bind((host, port))
            self.server_socket.settimeout(1.0)  # Set timeout for socket operations
            
            self.server_running = True
            self.server_thread = threading.Thread(target=self.run_server, daemon=True)
            self.server_thread.start()
            
            self.log_output.append(f"[SERVER] ƒêang l·∫Øng nghe t·∫°i {host}:{port}")
        except Exception as e:
            self.log_output.append(f"[SERVER ERROR] Kh√¥ng th·ªÉ kh·ªüi ƒë·ªông server: {e}")

    def stop_server(self):
        if not self.server_running:
            return
            
        self.server_running = False
        if self.server_socket:
            try:
                self.server_socket.close()
            except:
                pass
        
        if self.client_socket:
            try:
                self.client_socket.close()
            except:
                pass
                
        self.client_socket = None
        self.log_output.append("[SERVER] Server ƒë√£ d·ª´ng")
        self.signals.connection_status.emit(False)

    def run_server(self):
        try:
            self.server_socket.listen(1)
            self.signals.new_log.emit("[SERVER] ƒêang ch·ªù robot k·∫øt n·ªëi...")
            
            while self.server_running:
                try:
                    self.server_socket.settimeout(1.0)
                    client, addr = self.server_socket.accept()
                    self.client_socket = client
                    self.signals.new_log.emit(f"[SERVER] Robot ƒë√£ k·∫øt n·ªëi t·ª´ {addr}")
                    self.signals.connection_status.emit(True)
                    
                    # Sau khi k·∫øt n·ªëi, x·ª≠ l√Ω giao ti·∫øp v·ªõi robot
                    self.handle_robot_communication(client)
                except socket.timeout:
                    # Timeout l√† b√¨nh th∆∞·ªùng khi ch·ªù k·∫øt n·ªëi
                    continue
                except Exception as e:
                    if self.server_running:  # Ch·ªâ ghi log n·∫øu server v·∫´n ƒëang ch·∫°y
                        self.signals.new_log.emit(f"[SERVER ERROR] L·ªói ch·ªù k·∫øt n·ªëi: {e}")
                    break
        finally:
            if self.server_socket:
                try:
                    self.server_socket.close()
                except:
                    pass
            self.signals.new_log.emit("[SERVER] Server ƒë√£ d·ª´ng")

    def handle_robot_communication(self, client):
        while self.server_running:
            try:
                client.settimeout(1.0)
                data = client.recv(4096).decode().strip()
                
                if not data:  # K·∫øt n·ªëi b·ªã ƒë√≥ng
                    self.signals.new_log.emit("[SERVER] Robot ƒë√£ ng·∫Øt k·∫øt n·ªëi")
                    self.signals.connection_status.emit(False)
                    break
                
                self.signals.new_log.emit(f"[ROBOT] {data}")
                
                if data == "READY_FOR_NEW_PATH":
                    self.signals.path_requested.emit()
                elif data.startswith("ERROR:"):
                    self.signals.new_log.emit(f"[ROBOT ERROR] {data}")
                
            except socket.timeout:
                # Timeout l√† b√¨nh th∆∞·ªùng khi ch·ªù d·ªØ li·ªáu
                continue
            except Exception as e:
                if self.server_running:  # Ch·ªâ ghi log n·∫øu server v·∫´n ƒëang ch·∫°y
                    self.signals.new_log.emit(f"[SERVER ERROR] L·ªói giao ti·∫øp: {e}")
                break
                
        # ƒê√≥ng k·∫øt n·ªëi khi tho√°t kh·ªèi v√≤ng l·∫∑p
        try:
            client.close()
        except:
            pass
        self.client_socket = None
        self.signals.connection_status.emit(False)

    def handle_path_request(self):
        if not hasattr(self, 'current_path_index'):
            self.current_path_index = 0
            
        if not self.path or len(self.path) == 0:
            self.signals.new_log.emit("[SERVER] Robot y√™u c·∫ßu ƒë∆∞·ªùng h√†n, nh∆∞ng ch∆∞a c√≥ ƒë∆∞·ªùng h√†n n√†o")
            if self.client_socket:
                try:
                    self.client_socket.sendall(b"DONE")  # G·ª≠i DONE khi kh√¥ng c√≥ ƒë∆∞·ªùng h√†n
                    self.signals.new_log.emit("[SERVER] ƒê√£ g·ª≠i DONE (kh√¥ng c√≥ ƒë∆∞·ªùng h√†n)")
                except:
                    self.signals.new_log.emit("[SERVER ERROR] Kh√¥ng th·ªÉ g·ª≠i th√¥ng b√°o")
            return
            
        try:
            batch_size = 3  # M·ªói batch t·ªëi ƒëa 4 ƒëi·ªÉm
            
            # Ki·ªÉm tra xem ƒë√£ g·ª≠i h·∫øt ƒëi·ªÉm ch∆∞a
            if self.current_path_index >= len(self.path):
                # ƒê√£ g·ª≠i xong t·∫•t c·∫£ c√°c ƒëi·ªÉm, g·ª≠i DONE
                if self.client_socket:
                    self.client_socket.sendall(b"DONE")
                    self.signals.new_log.emit("[SERVER] ƒê√£ g·ª≠i DONE (ho√†n th√†nh ƒë∆∞·ªùng h√†n)")
                    self.current_path_index = 0  # Reset l·∫°i ƒë·ªÉ l·∫ßn sau c√≥ th·ªÉ g·ª≠i t·ª´ ƒë·∫ßu
                return
            
            # T√≠nh s·ªë ƒëi·ªÉm c√≤n l·∫°i ƒë·ªÉ g·ª≠i
            remaining_points = len(self.path) - self.current_path_index
            # L·∫•y s·ªë ƒëi·ªÉm cho batch hi·ªán t·∫°i (t·ªëi ƒëa batch_size)
            points_to_send = min(batch_size, remaining_points)
            
            # L·∫•y batch ƒëi·ªÉm ti·∫øp theo
            current_batch = self.path[self.current_path_index:self.current_path_index + points_to_send]
            
            # ƒê·ªãnh d·∫°ng s·ªë th·ª±c v·ªõi 2 ch·ªØ s·ªë th·∫≠p ph√¢n ƒë·ªÉ tƒÉng ƒë·ªô ch√≠nh x√°c
            path_str = ";".join([f"{point[0]:.2f},{point[1]:.2f},{point[2]:.2f}" for point in current_batch])
            
            if self.client_socket:
                self.client_socket.sendall(path_str.encode())
                self.signals.new_log.emit(f"[SERVER] ƒê√£ g·ª≠i batch {self.current_path_index//batch_size + 1}: {points_to_send} ƒëi·ªÉm (t·ª´ ƒëi·ªÉm {self.current_path_index + 1} ƒë·∫øn {self.current_path_index + points_to_send})")
                
                # C·∫≠p nh·∫≠t index cho batch ti·∫øp theo
                self.current_path_index += points_to_send
                
        except Exception as e:
            self.signals.new_log.emit(f"[SERVER ERROR] Kh√¥ng th·ªÉ g·ª≠i ƒë∆∞·ªùng h√†n: {e}")

    def detect_weld(self):
        self.status_label.setText("ƒêang ph√°t hi·ªán...")
        self.log_output.append("[INFO] B·∫Øt ƒë·∫ßu ph√°t hi·ªán...")
        self.detect_btn.setEnabled(False)

        def task():
            points, line, roi = self.detector.detect_weld()
            if points:
                self.status_label.setText("Ph√°t hi·ªán th√†nh c√¥ng")
                self.path = points
                self.line = line
                self.roi = roi
                self.display_image(roi)
                self.plot_btn.setEnabled(True)
                self.reset_path_btn.setEnabled(True)
                self.log_output.append("[SUCCESS] M·ªëi h√†n ƒë√£ ƒë∆∞·ª£c ph√°t hi·ªán.")
                self.log_output.append(f"[INFO] T·∫°o ƒë∆∞·ªùng h√†n v·ªõi {len(points)} ƒëi·ªÉm")
                self.log_output.append("[INFO] Robot c√≥ th·ªÉ y√™u c·∫ßu ƒë∆∞·ªùng h√†n n√†y qua k·∫øt n·ªëi server")
                self.current_path_index = 0
            else:
                self.status_label.setText("Kh√¥ng ph√°t hi·ªán ƒë∆∞·ª£c")
                self.log_output.append("[WARNING] Kh√¥ng t√¨m th·∫•y m·ªëi h√†n.")
            self.detect_btn.setEnabled(True)

        threading.Thread(target=task).start()

    def display_image(self, img):
        rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        h, w, ch = rgb.shape
        bytes_per_line = ch * w
        qimg = QImage(rgb.data, w, h, bytes_per_line, QImage.Format_RGB888)
        pix = QPixmap.fromImage(qimg).scaled(800, 300, Qt.KeepAspectRatio)
        self.image_label.setPixmap(pix)

    def update_connection_status(self, connected):
        if connected:
            self.connection_status_label.setText("Tr·∫°ng th√°i k·∫øt n·ªëi: Robot ƒë√£ k·∫øt n·ªëi")
        else:
            self.connection_status_label.setText("Tr·∫°ng th√°i k·∫øt n·ªëi: Robot kh√¥ng k·∫øt n·ªëi")

    def append_log(self, message):
        self.log_output.append(message)
        # Auto-scroll to bottom
        self.log_output.verticalScrollBar().setValue(
            self.log_output.verticalScrollBar().maximum()
        )

    def show_plot(self):
        try:
            X, Y, Z = zip(*self.path)
            lx = [self.line[0], self.line[2]]
            ly = [self.line[1], self.line[3]]
            lz = [Z[0], Z[-1]]
            fig = plt.figure()
            ax = fig.add_subplot(111, projection='3d')
            ax.plot(X, Y, Z, 'g-', label='Zigzag Path')
            ax.scatter(X, Y, Z, c='r', label='Waypoints')
            ax.plot(np.array(lx), np.array(ly), lz, 'b-', label='Detected Line')
            ax.set_xlabel("X (mm)")
            ax.set_ylabel("Y (mm)")
            ax.set_zlabel("Z (mm)")
            ax.legend()
            plt.show()
        except Exception as e:
            self.log_output.append(f"[ERROR] Kh√¥ng th·ªÉ hi·ªÉn th·ªã ƒë·ªì th·ªã: {e}")

    def reset_current_path(self):
        """Reset ƒë∆∞·ªùng h√†n hi·ªán t·∫°i v√† index ƒë·ªÉ g·ª≠i l·∫°i t·ª´ ƒë·∫ßu"""
        self.current_path_index = 0
        self.log_output.append("[INFO] ƒê√£ reset ƒë∆∞·ªùng h√†n - s·∫Ω g·ª≠i l·∫°i t·ª´ ƒë·∫ßu khi robot y√™u c·∫ßu")
        self.reset_path_btn.setEnabled(len(self.path) > 0)

    def closeEvent(self, event):
        # D·ª´ng server khi ƒë√≥ng ·ª©ng d·ª•ng
        self.stop_server()
        event.accept()

if __name__ == '__main__':
    app = QApplication(sys.argv)
    gui = WeldGUI()
    gui.show()
    sys.exit(app.exec_())